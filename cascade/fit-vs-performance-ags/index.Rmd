---
title: "Fitness vs Performance Analysis (AGS paper I)"
author: "[John Zobolas](https://github.com/bblodfon)"
date: "Last updated: `r format(Sys.time(), '%d %B, %Y')`"
description: "Fitness vs Performance Analysis (AGS paper I)"
url: 'https\://bblodfon.github.io/gitsbe-model-analysis/cascade/fit-perf-ags/index.html'
github-repo: "bblodfon/gitsbe-model-analysis"
link-citations: true
site: bookdown::bookdown_site
---

# Intro {-}

:::{.green-box}
Main question: is there a correlation between models fitness to the steady state and their performance as measured by the MCC score?
:::

All boolean model simulations were done using the `druglogics-synergy` Java module, version `1.2.0`: `git checkout v1.2.0`.

This analysis was done after I concluded the ROC and PR analysis for the AGS paper I (see [here](https://bblodfon.github.io/ags-paper-1/index.html)).
Since the results of this analysis are negative, I put them here as an investigation and a reference guide for future endeavors!

# Input {-}

Load libraries:
```{r Load libraries, message = FALSE}
library(xfun)
library(emba)
library(usefun)
library(dplyr)
library(tibble)
library(stringr)
```

Load the AGS steady state:
```{r load ss data, results='asis', cache=TRUE}
# get the AGS steady state
steady_state_file = "data/steadystate"
lines = readLines(steady_state_file)
ss_data = unlist(strsplit(x = lines[8], split = "\t"))
ss_mat = stringr::str_split(string = ss_data, pattern = ":", simplify = TRUE)
colnames(ss_mat) = c("nodes", "states")
ss_tbl = ss_mat %>% as_tibble() %>% mutate_at(vars(states), as.integer)

steady_state = ss_tbl %>% pull(states)
names(steady_state) = ss_tbl %>% pull(nodes)

usefun::pretty_print_vector_names_and_values(vec = steady_state)
```

Load observed synergies:
```{r load obs synergies, results = 'asis', cache=TRUE}
# get observed synergies for Cascade 2.0
observed_synergies_file = "data/observed_synergies_cascade_2.0"
observed_synergies = emba::get_observed_synergies(observed_synergies_file)

pretty_print_vector_values(vec = observed_synergies, vector.values.str = "observed synergies")
```

# Flip training data analysis {-}

The idea here is to generate many training data files from the steady state, where some of the nodes will have their states *flipped* to the opposite state ($0$ to $1$ and vice versa).
That way, we can train models to different steady states, ranging from ones that differ to just a few nodes states up to a steady state that is the complete *reversed* version of the one used in the simulations.

Using the [gen_training_data.R](TODO add link) script, we first chose a few number of flips ($11$ flips) ranging from $1$ to $24$ (all nodes) in the steady state.
Then, for each such *flipping-nodes* value, we generated $20$ new steady states with a randomly chosen set of nodes whose value is going to flip.
Thus, in total, $205$ training data files were produced ($205 = 9 \times 20 + 24 + 1$, where from the $11$ number of flips, the one flip happens for every node ($24$ different steady states) and flipping all the nodes generates $1$ completely reversed steady state). 

Running the script [run_druglogics_synergy_training.sh](TODO add link) from the `druglogics-synergy` repository root (version `1.2.0`: `git checkout v1.2.0`), we get the simulation results for each of these training data files.
Note that in the CASCADE 2.0 configuration file (`config`) we changed the number of simulations to ($15$) for each training data file, the attractor tool used was `biolqm_stable_states` and the `synergy_method: hsa`.

The generated training data files and the results from the simulations are stored here [`training-data-files` DOI ZENODO].

To load the data, download the file of interest (`fit-vs-performance-results.tar.gz`) and extract it to a directory of your choice with the following commands: `mkdir fit-vs-performance-results` and `tar -C fit-vs-performance-results/ -xzvf fit-vs-performance-results.tar.gz`.
Then use the next R code to create the `res` data.frame (I have already saved the result):

```{r load fit-vs-performance dataset 1, include=FALSE, eval=FALSE}
# change appropriately
data_dir = "/home/john/tmp/ags_paper_res/fit-vs-performance-results"
res_dirs = list.files(data_dir, full.names = TRUE)

data_list = list()
index = 1
for (res_dir in res_dirs) {
  model_predictions_file = list.files(path = res_dir, pattern = "model_predictions.tab", full.names = TRUE)
  models_dir = paste0(res_dir, "/models")
  
  model_predictions = emba::get_model_predictions(model_predictions_file)
  models_link_operators = emba::get_link_operators_from_models_dir(models_dir)
  # you get messages for models with {#stable states} != 1
  models_stable_states = emba::get_stable_state_from_models_dir(models_dir)
  
  # same order => same model per row (also pruned if != 1 stable states)
  model_predictions = model_predictions[rownames(models_stable_states),]
  models_link_operators = models_link_operators[rownames(models_stable_states),]
  
  # calculate models MCC scores
  models_mcc = calculate_models_mcc(
    observed.model.predictions = model_predictions %>% select(all_of(observed_synergies)),
    unobserved.model.predictions = model_predictions %>% select(-all_of(observed_synergies)),
    number.of.drug.comb.tested = ncol(model_predictions))
  
  # calculate models fitness to AGS steady state
  models_fit = apply(models_stable_states[, names(steady_state)], 1, 
    usefun::get_percentage_of_matches, steady_state)
  
  # check data consistency
  stopifnot(all(names(models_mcc) == rownames(models_link_operators)))
  stopifnot(all(names(models_mcc) == names(models_fit)))
  
  # get link operator mutation code per model
  # same code => exactly same link operator mutations => exactly the same model
  link_mutation_binary_code = unname(apply(models_link_operators, 1, paste, collapse = ""))
  
  # bind all to one (OneForAll)
  df = bind_cols(
    model_code = link_mutation_binary_code, 
    mcc = models_mcc, fitness = models_fit)
  
  data_list[[index]] = df
  index = index + 1
}

res = bind_rows(data_list)

# prune to unique models
res_unique = res %>% distinct(model_code, .keep_all = TRUE)
```

```{r fit-vs-perf-figures, include=FALSE, eval=FALSE}
library(ggpubr)
library(Ckmeans.1d.dp)

# remove models with MCC = 0 (denominator = 0)
#res_unique = res_unique %>% filter(mcc != 0)

ggscatter(res_unique, x = "fitness", y = "mcc", add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.coeff.args = list(method = "kendall"))

### Fitness classes vs Fitness
fit_classes = res_unique %>% pull(fitness) %>% unique() %>% length()
fit_result = Ckmeans.1d.dp(x = res_unique$fitness, k = round(fit_classes/2))
fitness_class_id = fit_result$cluster
#res_unique = res_unique %>% select(-fitness_class_id)
res_unique = res_unique %>% add_column(fitness_class_id = fitness_class_id)
fit_stats = desc_statby(res_unique, measure.var = "mcc", grps = c("fitness_class_id"), ci = 0.95)

ggbarplot(fit_stats, title = "Fitness Class vs Performance (MCC)",
  x = "fitness_class_id", y = "mean", xlab = "Fitness Class",
  ylab = "Mean MCC", ylim = c(min(fit_stats$mean - 2*fit_stats$se), max(fit_stats$mean) + 0.1),
  label = fit_stats$length, lab.vjust = -5,  fill = "fitness_class_id") + 
  scale_x_discrete(labels = round(fit_stats$fitness, digits = 2)) + 
  scale_fill_gradient(low = "lightblue", high = "red", name = "Fitness Class", 
    guide = "legend", breaks = c(1,4,7,10)) + 
  geom_errorbar(aes(ymin=mean-2*se, ymax=mean+2*se), width = 0.2, position = position_dodge(0.9))

ggboxplot(res_unique, x = "fitness_class_id", y = "mcc", color = "fitness_class_id")

# useful
res_unique %>% group_by(fitness_class_id) %>% summarise(avg = mean(mcc), count = n()) %>% print(n = 21)
```

# Reverse SS vs SS method {-}

- 5000 simulations => `15000` models
- `HSA` synergy assessement (Drabme)
- res_link: `biolqm_stable_states`
- res_topo: `bnet_reduction_reduced`
- res_link_and_topo: `bnet_reduction_reduced`

Fit to steady state, to reverse steady state and proliferation profile

```{r a, include=FALSE, eval=FALSE}
# get observed synergies for Cascade 2.0
observed_synergies_file = "results/observed_synergies_cascade_2.0"
observed_synergies = emba::get_observed_synergies(observed_synergies_file)

# get the AGS steady state
steady_state_file = "scripts/steadystate"
lines = readLines(steady_state_file)
ss_data = unlist(strsplit(x = lines[8], split = "\t"))
ss_mat = stringr::str_split(string = ss_data, pattern = ":", simplify = TRUE)
colnames(ss_mat) = c("nodes", "states")
ss_tbl = ss_mat %>% as_tibble() %>% mutate_at(vars(states), as.integer)

steady_state = ss_tbl %>% pull(states)
names(steady_state) = ss_tbl %>% pull(nodes)

# simulation results directories (do not add the ending path character '/')
res_dirs = c("/home/john/tmp/ags_paper_res/topo-and-link/5000-sim-hsa-res/cascade_2.0_rev_5000sim_bnet_hsa_20200601_054944", 
  "/home/john/tmp/ags_paper_res/topo-and-link/5000-sim-hsa-res/cascade_2.0_rand_5000sim_bnet_hsa_20200601_155644",
  "/home/john/tmp/ags_paper_res/topo-and-link/5000-sim-hsa-res/cascade_2.0_ss_5000sim_bnet_hsa_20200531_202847")

res_dir = "/home/john/tmp/ags_paper_res/link-only/hsa/cascade_2.0_random_20200417_011251"

data_list = list()
index = 1
for (res_dir in res_dirs) {
  if (str_detect(pattern = "cascade_2.0_ss", string = res_dir)) {
    type = "ss" 
  } else if (str_detect(pattern = "cascade_2.0_rev", string = res_dir)) {
    type = "rev" 
  } else {
    type = "prolif" 
  }
  
  model_predictions_file = list.files(path = res_dir, pattern = "model_predictions.tab", full.names = TRUE)
  models_dir = paste0(res_dir, "/models")
  
  model_predictions = emba::get_model_predictions(model_predictions_file)
  #models_link_operators = emba::get_link_operators_from_models_dir(models_dir)
  # you get messages for models with {#stable states} != 1
  models_stable_states = emba::get_stable_state_from_models_dir(models_dir)
  
  # same order => same model per row (also pruned if != 1 stable states)
  model_predictions = model_predictions[rownames(models_stable_states),]
  #models_link_operators = models_link_operators[rownames(models_stable_states),]
  
  # calculate models MCC scores
  models_mcc = calculate_models_mcc(
    observed.model.predictions = model_predictions %>% select(all_of(observed_synergies)),
    unobserved.model.predictions = model_predictions %>% select(-all_of(observed_synergies)),
    number.of.drug.comb.tested = ncol(model_predictions))
  
  # calculate models fitness to AGS steady state
  models_fit = apply(models_stable_states[, names(steady_state)], 1, 
    usefun::get_percentage_of_matches, steady_state)
  
  # check data consistency
  #stopifnot(all(names(models_mcc) == rownames(models_link_operators)))
  stopifnot(all(names(models_mcc) == names(models_fit)))
  
  # get link operator mutation code per model
  # same code => exactly same link operator mutations => exactly the same model
  #link_mutation_binary_code = unname(apply(models_link_operators, 1, paste, collapse = ""))
  
  # bind all to one (OneForAll)
  #df = bind_cols(model_code = link_mutation_binary_code, mcc = models_mcc, 
  #  fitness = models_fit, type = rep(type, length(models_fit)))
  df = bind_cols(mcc = models_mcc, fitness = models_fit, type = rep(type, length(models_fit)))
  
  data_list[[index]] = df
  index = index + 1
}

res = bind_rows(data_list)
res_link = res
res_topo = res
res_link_and_topo = res

saveRDS(res_link, file = "res_link.rds")
saveRDS(res_topo, file = "res_topo.rds")
saveRDS(res_link_and_topo, file = "res_link_and_topo.rds")

# prune to unique models
#res_unique = res %>% distinct(model_code, .keep_all = TRUE)
```

```{r, include=FALSE, eval=FALSE}
# res %>% sample_n(size = 1000)
# res %>% filter(mcc > 0)
ggboxplot(data = res %>% filter(mcc > 0), x = "type", y = "mcc", 
  color = "type", palette = "Set1", order = c("rev", "prolif", "ss"),
  bxp.errorbar = TRUE, bxp.errorbar.width = 0.2,
  #add = "mean_se", add.params = list(color='green', size=0.8),
  ylab = "MCC score", xlab = "Training Data Type") + 
  stat_compare_means(label.x = 2.5) +
  ggtitle(label = "Performance (MCC) of different training data schemes", 
    subtitle = "Models with Link Operator Mutations")

ggdensity(data = res %>% filter(mcc > 0), x = "mcc", color = "type", add = "mean", #rug = TRUE,
  fill = "type", palette = "Set1", xlab = "MCC score") + 
  ggtitle(label = "MCC density profile for different training data schemes", 
    subtitle = "Models with Link Operator Mutations")
```


```{r include=FALSE, eval=FALSE}
### Fitness classes vs Fitness
fit_classes = res %>% pull(fitness) %>% unique() %>% length()
fit_result = Ckmeans.1d.dp(x = res$fitness, k = 5)
fitness_class_id = fit_result$cluster
#res_unique = res_unique %>% select(-fitness_class_id)
res = res %>% add_column(fitness_class_id = fitness_class_id)
fit_stats = desc_statby(res, measure.var = "mcc", grps = c("fitness_class_id"), ci = 0.95)

ggbarplot(fit_stats, title = "Fitness Class vs Performance (MCC)",
  x = "fitness_class_id", y = "mean", xlab = "Fitness Class",
  ylab = "Mean MCC", ylim = c(min(fit_stats$mean - 2*fit_stats$se), max(fit_stats$mean) + 0.1),
  label = fit_stats$length, lab.vjust = -5,  fill = "fitness_class_id") + 
  scale_x_discrete(labels = round(fit_stats$fitness, digits = 2)) + 
  scale_fill_gradient(low = "lightblue", high = "red", name = "Fitness Class", 
    guide = "legend", breaks = c(1,4,7,10)) + 
  geom_errorbar(aes(ymin=mean-2*se, ymax=mean+2*se), width = 0.2, position = position_dodge(0.9))

ggboxplot(res_unique, x = "fitness_class_id", y = "mcc", color = "fitness_class_id")
```

# R session info {-}

```{r session info, comment=""}
xfun::session_info()
```
