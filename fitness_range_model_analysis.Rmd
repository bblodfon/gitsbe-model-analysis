---
title: "Gitsbe Fitness Range Model Analysis"
output:
  html_document:
    df_print: paged
    #self_contained: no
---

## Intro

Goal
----
Fitness vs Performance statistical correlation
- performance metric to classify models: TP, MCC (2 opposite classes, or many!)
- prove that models with higher fitness to steady state are better at predicting 
synergies

Specifics
---------
specialized run of Gitsbe: 
simulations:	10, 
1 generation, 
Number of models per generation population:	10000, 10000 ideally selected, 
Number of models (tried) to save -> models_saved:	10000
models are fitted to steady state for the AGS cell line, and model synergy 
predictions are contrasted to the observed synergies from AGS cell line


This notebook includes the ensemble model analysis performed on the models 
generated by the `Gitsbe` module when running the DrugLogics computational 
pipeline for finding synergistic drug combinations (drug pairs). All these 
models were trained towards a specific steady state signaling pattern that was
derived based on input data (gene expression, CNV) for a particular cell line. 
The input for the simulations and the output data are in the `fitness-range-investigation` 
directory. The analysis will be presented step by step in the sections below.

The R version used for this analysis is: 
```{r R version}
R.version.string
```

## Prerequisites

Firstly, we load the required libraries (you need to install them if you don't
have them):
```{r Load libraries, message = FALSE}
library(RColorBrewer)
library(superheat) # version 1.0.0, see (Barter, 2017)
```
and the relevant helper functions:
```{r Helper functions}
# Set the working directory to the gitsbe-model-analysis folder: 
# setwd("pathTo/gitsbe-model-analysis")
source("Rscripts/input_functions.R")
source("Rscripts/output_functions.R")
source("Rscripts/analysis_functions.R")
source("Rscripts/plot_functions.R")
```

## Input

```{r Input: Cell line and Data directory}
cell.line = "AGS"
data.dir = paste0(getwd(), "/fitness-range-investigation/")
```
**Three inputs** are used in this analysis:

- The **model_predictions** file which has for each model the prediction for 
each drug combination tested (*0* = no synergy predicted, *1* = synergy 
predicted, *NA* = couldn't find stable states in either the drug combination 
inhibited model or in any of the two single-drug inhibited models)
- The **observed_synergies** file which lists the drug combinations that were 
observed as synergistic for the particular cell line.
- The **models** directory, which is the same as the models directory produced 
by `Gitsbe` and has one `.gitsbe` file per model that includes this info:
    - The *fitness* to the steady state (value between 0 and 1)
    - The *stable state* of the boolean model. Note that a model can have 1 
stable state or none in our simulations - but the models used in this analysis 
have been selected through a genetic evolution algorithm in `Gitsbe` and so in 
the end, only those with 1 stable state have higher fitness values and remain in 
the later generations. Higher fitness here means a better match of a model's 
stable state to the cell line derived steady state (a perfect match would result 
in a fitness of 1)
    - The *boolean equations* of the model

```{r Input: files}
model.predictions.file = paste0(data.dir, "model_predictions")
observed.synergies.file = paste0(data.dir, "observed_synergies")
models.dir = paste0(data.dir, "models")
```
Now, we parse the data into proper R objects. First the synergy predictions 
per model:
```{r Input: model predictions}
model.predictions = get.model.predictions(model.predictions.file)
head(model.predictions)
```
So, we can see that our dataset has the models as rows and each column is a 
different drug combination that was tested in our simulations.
```{r Model&Drug Stats}
drug.combinations.tested = colnames(model.predictions)
models                   = rownames(model.predictions)
nodes                    = get.node.names(models.dir)

number.of.drug.comb.tested = length(drug.combinations.tested)
number.of.models           = length(models)
number.of.nodes            = length(nodes)

print.model.and.drug.stats(number.of.drug.comb.tested, number.of.models, 
                           number.of.nodes)
```

We also keep track of each model fitness to the steady state (a value closer 
to 1 corresponds to a better fit to the steady state profile):
```{r Input: models fitness}
models.fitness = get.fitness.from.models.dir(models.dir)
models.fitness = models.fitness[models]
head(as.data.frame(models.fitness))
```

```{r Fitness stats}
fitness.range = range(models.fitness)
print(paste("Minimum fitness value: ", min(fitness.range)))
print(paste("Maximum fitness value: ", max(fitness.range)))

model.count.per.fitness = table(models.fitness)
number.of.unique.fitness.values = length(model.count.per.fitness)
print(paste("Unique fitness values:", number.of.unique.fitness.values))
```

```{r Fitness stats}
y.axis.values = pretty(model.count.per.fitness)
plot(names(model.count.per.fitness), model.count.per.fitness, 
     type = "l",  yaxt = "n",
     xlab = "Fitness",
     ylab = "Number of models",
     main = "Distribution of fitness among models")
axis(2, at = y.axis.values, las = 1)
```

Lastly, the synergies observed for this particular cell line are:
```{r Input: observed synergies}
observed.synergies = get.observed.synergies(
  observed.synergies.file, drug.combinations.tested)
number.of.observed.synergies = length(observed.synergies)

print(paste("Number of synergies observed:", number.of.observed.synergies))
observed.synergies
```

## Statistical Analysis

```{r Stats}
# Subset the model.data to the observed synergies
observed.model.predictions = 
  model.predictions[,sapply(drug.combinations.tested, function(drug.comb) {
    is.correct.synergy(drug.comb, observed.synergies)
  })]

# Subset the model.data to the unobserved synergies
unobserved.model.predictions = 
  model.predictions[,sapply(drug.combinations.tested, function(drug.comb) {
    !is.correct.synergy(drug.comb, observed.synergies)
  })]

stopifnot(dim(observed.model.predictions)[2] + 
          dim(unobserved.model.predictions)[2] == number.of.drug.comb.tested)

# Count the predictions of the observed synergies per model (TP)
models.synergies.tp = apply(observed.model.predictions, 1, sum, na.rm = T)
models.synergies.tp.stats = table(models.synergies.tp)
tp.values = as.numeric(names(models.synergies.tp.stats))

# Bar plot of number of models vs correctly predicted synergies
make.barplot.on.models.stats(models.synergies.tp.stats, cell.line, 
                            title = "True Positive Synergy Predictions",
                            xlab = "Number of maximum correctly predicted synergies",
                            ylab = "Number of models")
```


```{r TP-classification of fitness values}
fitness.tp = list(length(tp.values))

i = 0
for (value in tp.values) {
  i = i + 1
  fitness.tp[[i]] = models.fitness[models.synergies.tp == value]
}
names(fitness.tp) = tp.values

# Hypothesis testing
kruskal.test(fitness.tp)

# ploting data (values and density estimations)
cols = brewer.pal(length(tp.values), "Set1")
boxplot(fitness.tp, main = "Fitness vs Performance (TP)", 
        xlab = "Number of TP predictions",
        ylab = "Fitness score",
        col = cols)
  
densities = lapply(fitness.tp, density)
make.multiple.density.plot(densities, legend.title = "#TP",
        title = "Density Estimation", x.axis.label = "Fitness score")
```

SOS: No correlation between fitness and number of TP predictions:
```{r Correlation Fitness vs number of TP predictions, fig.height=15, fig.width=7}
sample.size = 100
number.of.samples = 5

par(mfrow = c(number.of.samples, 2))
for (num in 1:number.of.samples) {
  # sampling data
  fitness.tp.sampled = lapply(fitness.tp, function(fit.vector) {
    return(sample(fit.vector, size = sample.size, replace = FALSE))
  })
  
  # Null hypothesis testing: the location parameters of the distribution
  # of `fitness.tp.sampled` are the same in each group (sample)
  kw.test.res = kruskal.test(fitness.tp.sampled)
  
  # ploting data (values and density estimations)
  cols = brewer.pal(length(tp.values), "Set1")
  boxplot(fitness.tp.sampled, main = "Fitness vs Performance (TP)", 
          xlab = "Number of TP predictions",
          ylab = "Fitness score",
          col = cols)
  
  densities = lapply(fitness.tp.sampled, density)
  make.multiple.density.plot(densities, legend.title = "#TP",
          title = "Density Estimation", x.axis.label = "Fitness score")
  legend("topleft", legend = 
          paste("p-value =", specify.decimal(kw.test.res$p.value, 3)))
}
```


```{r Calculate MCC}
# Count the false negatives (FN)
models.synergies.fn = apply(observed.model.predictions, 1, function(x) {
  sum( x == 0 | is.na(x) )
})

# P = TP + FN (Positives)
positives = ncol(observed.model.predictions)
models.synergies.p = models.synergies.tp + models.synergies.fn

# Count the predictions of the non-observed synergies per model (FP)
models.synergies.fp = apply(unobserved.model.predictions, 1, sum, na.rm = T)

# Count the True Negatives (TN)
models.synergies.tn = apply(unobserved.model.predictions, 1, function(x) {
  sum( x == 0 | is.na(x))
})

# N = FP + TN (Negatives)
negatives = ncol(unobserved.model.predictions)
models.synergies.n = models.synergies.fp + models.synergies.tn

# checks
stopifnot(models.synergies.p == positives)
stopifnot(models.synergies.n == negatives)
stopifnot(positives + negatives == number.of.drug.comb.tested)

# Calculate Matthews Correlation Coefficient (MCC)
models.mcc = calculate.mcc(models.synergies.tp, models.synergies.tn, 
                           models.synergies.fp, models.synergies.fn,
                           positives, negatives)
models.mcc.stats = table(models.mcc, useNA = "ifany")
print("MCC value range:")
range(models.mcc, na.rm = TRUE)
```

```{r NaN MCC score}
sum(models.synergies.tp + models.synergies.fp == 0)
```

```{r MCC stats}
# show only mcc values >= 100
make.barplot.on.models.stats(models.mcc.stats, cell.line, title = "MCC scores", 
                             xlab = "MCC value", ylab = "Number of models", 
                             cont.values = TRUE, threshold = 99)
```

```{r MCC classification}
mcc.values = as.numeric(names(models.mcc.stats))

# split into classes with a 0.2 MCC value range each
mcc.intervals = get.mcc.intervals(mcc.values, interval.size = 0.2)

# add NaN category (if applicable)
if (sum(is.na(mcc.values)) > 0) {
  mcc.intervals = rbind(c(NaN, NaN), mcc.intervals)
}

mcc.classes = get.mcc.classes(mcc.intervals)
print.mcc.classification.info(mcc.classes)
```


```{r Calculate other measures of performance evaluation}
# False Positive Rate (FPR), Accuracy
models.tpr = models.synergies.tp / models.synergies.p # Sensitivity/Recall
models.tnr = models.synergies.tn / models.synergies.n # Specificity
models.ppv = models.synergies.tp / (models.synergies.tp + models.synergies.fp) # precision
models.fpr = models.synergies.fp / models.synergies.n
models.accuracy = (models.synergies.tp + models.synergies.tn) / 
                  (models.synergies.p + models.synergies.n)
```

```{r Graphs: Fitness vs Evaluation metrics}
fitness.vs.avg.fp = 
  get.average.over.unique.values(models.fitness, models.synergies.fp)
fitness.vs.avg.tp = 
  get.average.over.unique.values(models.fitness, models.synergies.tp)
fitness.vs.avg.fn = 
  get.average.over.unique.values(models.fitness, models.synergies.fn)
fitness.vs.avg.tn = 
  get.average.over.unique.values(models.fitness, models.synergies.tn)

x = fitness.vs.avg.fp[,1]
avg = fitness.vs.avg.fp[,2]
sdev = fitness.vs.avg.fp[,3]
plot(fitness.vs.avg.fp, ylim=range(c(avg-sdev, avg+sdev)), 
     xlab = "Fitness Score", ylab = "Number of FP predictions",
     main = "Average FP per unique fitness score")
#arrows(x, avg-sdev, x, avg+sdev, length=0.05, angle=90, code=3)


x = fitness.vs.avg.tp[,1]
avg = fitness.vs.avg.tp[,2]
sdev = fitness.vs.avg.tp[,3]
plot(fitness.vs.avg.tp, ylim=range(c(avg-sdev, avg+sdev)), 
     xlab = "Fitness Score", ylab = "Number of TP predictions",
     main = "Average TP per unique fitness score")

x = fitness.vs.avg.tn[,1]
avg = fitness.vs.avg.tn[,2]
sdev = fitness.vs.avg.tn[,3]
plot(fitness.vs.avg.tn, ylim=range(c(avg-sdev, avg+sdev)), 
     xlab = "Fitness Score", ylab = "Number of TN predictions",
     main = "Average TN per unique fitness score")

x = fitness.vs.avg.fn[,1]
avg = fitness.vs.avg.fn[,2]
sdev = fitness.vs.avg.fn[,3]
plot(fitness.vs.avg.fn, ylim=range(c(avg-sdev, avg+sdev)), 
     xlab = "Fitness Score", ylab = "Number of FN predictions",
     main = "Average FN per unique fitness score")
```

```{r}
fitness.vs.avg.tpr = 
  get.average.over.unique.values(models.fitness, models.tpr)
fitness.vs.avg.tnr = 
  get.average.over.unique.values(models.fitness, models.tnr)
fitness.vs.avg.ppv = 
  get.average.over.unique.values(models.fitness, models.ppv)
fitness.vs.avg.fpr = 
  get.average.over.unique.values(models.fitness, models.fpr)
fitness.vs.avg.accuracy = 
  get.average.over.unique.values(models.fitness, models.accuracy)

x = fitness.vs.avg.tpr[,1]
avg = fitness.vs.avg.tpr[,2]
sdev = fitness.vs.avg.tpr[,3]
plot(fitness.vs.avg.tpr, ylim=range(c(avg-sdev, avg+sdev)), 
     xlab = "Fitness Score", ylab = "TPR",
     main = "Average TPR per unique fitness score")

x = fitness.vs.avg.tnr[,1]
avg = fitness.vs.avg.tnr[,2]
sdev = fitness.vs.avg.tnr[,3]
plot(fitness.vs.avg.tnr, ylim=range(c(avg-sdev, avg+sdev)), 
     xlab = "Fitness Score", ylab = "TNR",
     main = "Average TNR per unique fitness score")

# Nan problem

# x = fitness.vs.avg.ppv[,1]
# avg = fitness.vs.avg.ppv[,2]
# sdev = fitness.vs.avg.ppv[,3]
# plot(fitness.vs.avg.ppv, ylim=range(c(avg-sdev, avg+sdev)), 
#      xlab = "Fitness Score", ylab = "PPV")

x = fitness.vs.avg.fpr[,1]
avg = fitness.vs.avg.fpr[,2]
sdev = fitness.vs.avg.fpr[,3]
plot(fitness.vs.avg.fpr, ylim=range(c(avg-sdev, avg+sdev)), 
     xlab = "Fitness Score", ylab = "FPR",
     main = "Average FPR per unique fitness score")

x = fitness.vs.avg.accuracy[,1]
avg = fitness.vs.avg.accuracy[,2]
sdev = fitness.vs.avg.accuracy[,3]
plot(fitness.vs.avg.accuracy, ylim=range(c(avg-sdev, avg+sdev)), 
     xlab = "Fitness Score", ylab = "Accuracy",
     main = "Average Accuracy per unique fitness score")
```
