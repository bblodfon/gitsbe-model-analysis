---
title: "Gitsbe Model Prediction Performance Analysis"
output:
  html_document:
    df_print: paged
---

## Intro

This notebook includes the ensemble model analysis performed on the models 
generated by the Gitsbe module when running the DrugLogics computational 
pipeline for finding synergistic drug combinations. The analysis will be 
presented step by step in the sections below.

The R version used for this analysis is: **3.4.4 (Someone to Lean On)**.

## Prerequisites

Firstly, we load the required libraries (you need to install them if you don't
have them):

```{r message=FALSE}
# require(RColorBrewer)
# require(heatmap.plus)
# require(gplots)
# require(rje)
```

and the relavant helper functions:

```{r}
setwd(".")
source("Rscripts/input_functions.R")
source("Rscripts/output_functions.R")
source("Rscripts/analysis_functions.R")
#source("Rscripts/plot_functions.R")
```

## Input

We will define the name of the cell line which must match the name of the 
directory that has the input files. There are **3 inputs** used in this 
analysis:

- The **model_predictions** file which has for each model the prediction for 
each synergy combination (either *0* = no synergy predicted, *1* = synergy 
predicted, *NA* = couldn't find stable states in either the drug combination 
or in any of the single drugs used in the model)
- The **observed_synergies** file which lists the drug combinations that were 
observed as synergistic.
- The **models** directory, which is the same as the models directory produced 
by Gitsbe and has one .gitsbe file per model and includes this info:
    - The *fitness* to the steady state (value between 0 and 1)
    - The *stable state* of the boolean model (can be either 1 stable state or 
none - the later rarely happens if not at all, since the models have been 
selected through a genetic evolution algorithm in Gitsbe and so in the end, only
those with at least one stable state have higher fitness values and stay in the 
later generations) 
    - The *boolean equations* of the model

```{r}
cell.line = "AGS"
data.dir = paste(getwd(), "/cell_lines_res_500/", cell.line, "/", sep = "")
results.dir = paste(data.dir, "results", sep = "")
dir.create(results.dir, showWarnings = FALSE)
model.predictions.file = paste(data.dir, "model_predictions", sep = "")
observed.synergies.file = paste(data.dir, "observed_synergies", sep = "")
models.dir = paste(data.dir, "models", sep = "")
```
Now, we parse the data into proper R objects. First the synergy predictions 
per model:
```{r}
model.data = read.model.predictions.file(model.predictions.file)
head(model.data)
```
So, we can see that our dataset has the models as rows and each column is a 
different drug combination that was tested in our simulations.
```{r}
drug.combinations.tested = colnames(model.data)
models                   = rownames(model.data)

models.number        = dim(model.data)[1]
drug.comb.number     = dim(model.data)[2]
print(paste("Drug combinations tested: ", drug.comb.number, ",",
            "Number of models: ", models.number))
```
 The synergies observed are:
```{r}
synergy.observations.data = read.observed.synergies.file(
  observed.synergies.file, drug.combinations.tested)
synergy.observations.data
```
Next, we get the full stable state, the equations and fitness value per model:
```{r}
models.stable.state = get.stableState.from.models.dir(models.dir)
models.stable.state = models.stable.state[models,]
head(as.data.frame(models.stable.state))
```
The rows of the above dataset represent the models while the columns are the
names of the nodes (proteins, genes, etc.) of the cancer cell network under 
study. So, each model has one stable state which means that in every model, the 
nodes in the network have been assigned a value of either 0 (inhibition) or 1 
(activation).
```{r}
models.equations = get.equations.from.models.dir(
  models.dir, removeEquationsHavingLinkOperator = TRUE)
models.equations = models.equations[models,]
head(as.data.frame(models.equations))
```
For the equations, if we look at a specific row (a model so to speak), the 
columns (node names) correspond to the *targets of regulation* (and the network 
has been built so that *every node is a target* - i.e. it has other nodes 
activating or inhibiting it). The general form of a boolean equation is: 
**Target \*= (Activator OR Activator OR...) AND NOT (Inhibitor OR Inhibitor 
OR...)**.

The difference between the models' boolean equations is the link operator 
(OR/AND) which has been mutated (changed) through the evolutionary process of 
the genetic algorithm in Gitsbe. For example, if a model has for the column 
ERK_f a value of 1, the correspoding equation is: ERK_f \*= (MEK_f) **OR NOT** 
((DUSP6) OR PPP1CA). A value of 0 would correspond to **AND NOT** in that case.
Note that the equations that do not have link operators (meaning that they are 
*the same for every model*) are discarded (so less columns in this dataset) 
since we want to see the change/difference between the models.

We, also keep track of each model fitness to the steady state (a value closer 
to 1 corresponds to a better fit to the steady state profile):
```{r}
models.fitness = get.fitness.from.models.dir(models.dir)
models.fitness = models.fitness[models]
head(as.data.frame(models.fitness))
```

## Statistical Analysis
```{r}
# Subset the model.data to only the observed synergies
observed.model.data =
  model.data[,sapply(drug.combinations.tested, function(c) {
    is.correct.synergy(c, synergy.observations.data)
  })]
# Subset the model.data to the unobserved synergies
unobserved.model.data =
  model.data[,sapply(drug.combinations.tested, function(c) {
    !is.correct.synergy(c, synergy.observations.data)
  })]

# Count the predictions of the observed synergies per model (TP)
models.synergies.tp = apply(observed.model.data, 1, sum, na.rm = T)
model.synergies.stats = table(models.synergies.tp)

# Count the false negatives (FN)
models.synergies.fn = apply(observed.model.data, 1, function(x) {
  sum( x == 0 | is.na(x) )
})

# P = TP + FN (Positives)
positives = ncol(observed.model.data)
models.synergies.p = models.synergies.tp + models.synergies.fn
stopifnot(sum(models.synergies.p == positives) == length(models.synergies.p))

# Count the predictions of the non-observed synergies per model (FP)
models.synergies.fp = apply(unobserved.model.data, 1, sum, na.rm = T)

# Count the True Negatives (TN)
models.synergies.tn = apply(unobserved.model.data, 1, function(x) {
  sum( x == 0 | is.na(x))
})

# N = FP + TN (Negatives)
negatives = ncol(unobserved.model.data)
models.synergies.n = models.synergies.fp + models.synergies.tn
stopifnot(sum(models.synergies.n == negatives) == length(models.synergies.n))

# Calculate the Sensitivity/Recall (TPR), Specificity (TNR), 
# Precision (PPV) and False Positive Rate (FPR)
models.sensitivity = models.synergies.tp / models.synergies.p
models.specificity = models.synergies.tn / models.synergies.n
models.precision   = models.synergies.tp / 
  (models.synergies.tp + models.synergies.fp)
models.fpr         = models.synergies.fp / models.synergies.n

# save stats all together in one file
measure.stats = cbind(models.fitness, models.synergies.tp, 
                      models.synergies.fp, models.synergies.tn, 
                      models.synergies.fn, models.sensitivity, 
                      models.specificity, models.precision, models.fpr)
output.data.to.file(results.dir, 
                    paste("statistical_measures_", cell.line, ".txt", sep = ""),
                    measure.stats, with.col.names = TRUE)
```

```{r}
# ROC curve
roc = get.average.over.unique.values(models.fpr, models.sensitivity)
roc = rbind(c(0,0,0), roc, c(1,1,0))
plot(roc, xlim = c(0,1), ylim = c(0,1), type = "o", main = "ROC curve")
```

```{r}
# Next plot makes more sense:
fitness.vs.avg.fp = 
  get.average.over.unique.values(models.fitness, models.synergies.fp)
x = fitness.vs.avg.fp[,1]
avg = fitness.vs.avg.fp[,2]
sdev = fitness.vs.avg.fp[,3]
plot(fitness.vs.avg.fp, ylim=range(c(avg-sdev, avg+sdev)))
arrows(x, avg-sdev, x, avg+sdev, length=0.05, angle=90, code=3)
```

